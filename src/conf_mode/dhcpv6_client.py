#!/usr/bin/env python3
#
# Copyright (C) 2019 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

import os
import subprocess
import sys

import jinja2

from vyos.config import Config
from vyos import ConfigError

config_file = r'/var/lib/dhcp/dhclient_v6_{}.delegations'

config_tmpl = """### Autogenerated by dhcpv6_pd.py ###
# Format: interface [/ sla_id [/ prefix_len [/ iid]]]
# The interface may be any interface other than the one that the prefix
# was requested on.
# sla_id defaults to the OS interface index.
# prefix_len defaults to 64.
# iid is the interface identifier (the host part) and defaults to ::1.
{% for sf in short_forms -%}
{{ sf }}
{% endfor -%}
"""


def get_ifindex(ifname):
    with open('/sys/class/net/{}/ifindex'.format(ifname), 'r') as ifindex:
        return ifindex.read().replace('\n', '')


def get_config(iftype, ifname):
    # The DHCPv6 client config is spread across three sections in an interface
    # node: 'address dhcp', 'dhcpv6-options', and 'dhcpv6-pd'. If either the
    # first or the last of these exists, then we need to configure and run the
    # dhcp client.
    conf = Config()
    addr_conf_path = 'interfaces {} {} address dhcpv6'.format(iftype, ifname)
    options_conf_path = 'interfaces {} {} dhcpv6-options'.format(iftype, ifname)
    pd_conf_path = 'interfaces {} {} dhcpv6-pd'.format(iftype, ifname)
    if not conf.exists(addr_conf_path) and not conf.exists(pd_conf_path):
        return None

    config = {
        'ifname': ifname,       # The interface DHCPv6 is running on
        'get_addr': None,       # An IPv6 address should be requested
        'options': {            # Options from dhcpv6-options
            'duid': None,
            'parameters-only': None,
            'temporary': None,
        },
        'req_pd': False,        # A Delegated Prefix should be requested
        'delegations': [],      # Delegation assignments for local interfaces
        'pd_prefix_hint': None, # A prefix length hint to send to the server
    }

    # Get the address config
    config['get_addr'] = conf.exists(addr_conf_path)

    # Get the dhcpv6-options config
    # (We can only ever call conf.set_level() once, so we do that for the last
    # configuration tag node we care about.
    if conf.exists(options_conf_path):
        duid_path = '{} duid'.format(options_conf_path)
        if conf.exists(duid_path):
            config['options']['duid'] = conf.return_value(duid_path)
        config['options']['parameters-only'] = conf.exists(
            '{} parameters-only'.format(options_conf_path))
        config['options']['temporary'] = conf.exists(
            '{} temporary'.format(options_conf_path))

    # Get the dhcpv6-pd config
    if conf.exists(pd_conf_path):
        config['req_pd'] = True
        conf.set_level(pd_conf_path)

        if conf.exists('interface'):
            for node in conf.list_nodes('interface'):
                options = {
                    'ifname': node,
                    'sla_id': conf.return_value(
                        'interface {0} sla-id'.format(node)),
                    'prefix_len': conf.return_value(
                        'interface {0} prefix-length'.format(node)),
                    'host_part': conf.return_value(
                        'interface {0} host-address'.format(node)),
                }
                if options['host_part']:
                    options['host_part'] = options['host_part']
                config['delegations'].append(options)

        if conf.exists('prefix-length-hint'):
            config['pd_prefix_hint'] = conf.return_value('prefix-length-hint')

    return config


def verify(config):
    # Having no configuration at all is valid.
    if config is None:
        return None

    options = config['options']

    # The parameters-only and temporary dhcpv6-options are mutually exclusive.
    if options['parameters-only'] and options['temporary']:
        raise ConfigError(
            'The temporary and parameters-only options are mutually exclusive')

    # The parameters-only dhcpv6-option and DHCPv6 prefix delegation are
    # mutually exclusive.
    if options['parameters-only'] and options['req_pd']:
        raise ConfigError('The parameters-only option and prefix delegation are mutually exclusive')

    return None


def generate(config):
    if config is None:
        # Looks like removal from the running config
        return None

    # The main DHCPv6 config file for this interface is written bu the
    # legacy Perl script. The only thing that needs to be generated here
    # is the Prefix Delegation config file.

    if not config['req_pd']:
        # No prefix delegation has been requested, so there's no
        # delegation config file to generate.
        return None

    # Generate the DHCPv6-PD configuration; the dhclient.conf file is
    # currently generated in vyatta-dhcpv6-client.pl (although that should
    # someday be refactored into here).
    short_forms = []
    for d in config['delegations']:
        if (d['prefix_len'] or d['host_part']) and not d['sla_id']:
            d['sla_id'] = get_ifindex(d['ifname'])

        if d['host_part'] and not d['prefix_len']:
            d['prefix_len'] = '64'

        options = [d['ifname']]

        if d['sla_id']:
            options.append(d['sla_id'])

        if d['prefix_len']:
            options.append(d['prefix_len'])

        if d['host_part']:
            options.append(d['host_part'])

        short_forms.append('/'.join(options))

    tmpl = jinja2.Template(config_tmpl)
    config_text = tmpl.render({ 'short_forms': short_forms})
    with open(config_file.format(config['ifname']), 'w') as f:
        f.write(config_text)

    return None


def apply(config, ifname):
    # For the moment, we still delegate the work of writing the DHCP config
    # file and starting and stopping the dhclient daemon to the legacy
    # Perl script. Eventually, it should be migrated into here, as well.
    if config is None:
        # Stop the dhclient daemon; its services are no longer required.
        print('Stopping dhclient on', ifname)
        args = ['--ifname', ifname]
        os.system(' '.join(
            ['sudo /opt/vyatta/sbin/vyatta-dhcpv6-client.pl --stop'] + args))
        if config['delegations'] is None:
            # DHCPv6-PD is removed in the commit.
            os.unlink(config_file.format(ifname))
        return None

    # The new config file will take effect the next time a prefix delegation
    # is obtained. We should force that by refreshing the DHCPv6 lease. The
    # easiest way to accomplish that right now is to restart the daemon.
    args = ['--ifname {}'.format(ifname)]
    if config['options']['parameters-only']:
        args.append('--parameters-only')
    if config['options']['temporary']:
        args.append('--temporary')
    if config['req_pd']:
        args.append('--prefix-delegation')
        if config['pd_prefix_hint']:
            dhclient_version = subprocess.check_output(
                ['/sbin/dhclient', '--version'],
                stderr=subprocess.STDOUT).decode('utf-8')
            if '4.3' in dhclient_version:
                # prefix-length-hint was added in dhclient 4.4, which is the
                # next minor version after the 4.3.1 currently shipped in VyOS.
                print('Warning: dhclient', dhclient_version,
                    'does not suport prefix-length-hint.')
                print('Ignoring this option for now.')
            else:
                args.append('--prefix-len-hint')
                args.append(config['pd_prefix_hint'])
        if config['get_addr']:
            args.append('--also-ia-na')
    os.system(' '.join(
        ['sudo /opt/vyatta/sbin/vyatta-dhcpv6-client.pl --stop --start'] + args))
    return None

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Arguments (listen interface type and name) are required")
        sys.exit(1)
    else:
        listen_iftype = sys.argv[1]
        listen_ifname = sys.argv[2]

    try:
        c = get_config(listen_iftype, listen_ifname)
        verify(c)
        generate(c)
        apply(c, listen_ifname)
    except ConfigError as e:
        print(e)
        sys.exit(1)